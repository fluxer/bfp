# -*- python -*-
#     Copyright 2014, Kay Hayen, mailto:kay.hayen@gmail.com
#
#     Part of "Nuitka", an optimizing Python compiler that is compatible and
#     integrates with CPython, but also works on its own.
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#

# The Nuitka scons file. If you have Scons or platform knowledge, please be
# especially invited and contribute improvements.
#
# This file is used to build an executable or shared library. Nuitka needs no
# build process for itself, although it can be compiled using the same method.

import os, subprocess, sys, re, platform

# The directory containing the C++ files generated by Nuitka to be built using
# scons. They are referred to as sources from here on. The ARGUMENTS is what
# Scons provides to us.
source_name = ARGUMENTS[ "name" ]
source_dir = ARGUMENTS[ "source_dir" ]

# The directory containing Nuitka provided C++ files to be built and where it
# should be used.
nuitka_src = ARGUMENTS[ "nuitka_src" ]
static_src = os.path.join( source_dir, "static" )

# We tell Scons that it is a variant to be built, so object files don't end up
# inside that directory which need not be writable.
VariantDir(static_src, os.path.join(nuitka_src, "static_src"), 0)

# The name of executable or loadable module that we produce.
result_basepath = ARGUMENTS["result_name"]

def getBoolOption( option_name, default ):
    """ Small helper for boolean mode flags."""
    value = ARGUMENTS.get( option_name, "True" if default else "False" )

    return value.lower() in ( "yes", "true", "1" )

# The directory to use for cache directory.
cache_mode = getBoolOption( "cache_mode", False )

# Module mode: Create a Python extension module, create an executable otherwise.
module_mode = getBoolOption( "module_mode", False )

# Debug mode: Less optimizations, debug information in the resulting binary.
debug_mode = getBoolOption( "debug_mode", False )

# Python version to target.
python_version = ARGUMENTS[ "python_version" ]

# Python debug mode: refcount checking, assertions in CPython core.
python_debug = getBoolOption( "python_debug", False )

# Optimization mode: Optimize as much as currently possible.
optimize_mode = getBoolOption( "optimize_mode", True )

# Full compatibility, even where it's stupid, i.e. do not provide information,
# even if available, in order to assert maximum compatibility. Intended to
# control level of compatability to absurd.
full_compat_mode = getBoolOption( "full_compat", False )

# Experimental mode. Do things that are not yet safe to do.
experimental_mode = getBoolOption( "experimental", False )

# LTO mode: Use link time optimizations of g++ compiler if available and known
# good with the compiler in question. The 4.5 one didn't have good enough
# support, the compiled result would not run correctly.
lto_mode = getBoolOption( "lto_mode", False )

# Windows target mode: Compile for Windows.
win_target = getBoolOption( "win_target", os.name == "nt" )

# Windows subsystem mode: Disable console for windows builds.
win_disable_console = getBoolOption( "win_disable_console", False )

# Unstriped mode: Do not remove debug symbols.
unstriped_mode = getBoolOption( "unstriped_mode", False )

# Clang compiler mode, default on MacOS X and FreeBSD, optional on Linux.
clang_mode = getBoolOption( "clang_mode", False )
if sys.platform == "darwin" or "freebsd" in sys.platform:
    clang_mode = True

# MinGW compiler mode, optional and interesting to Windows only.
mingw_mode = getBoolOption( "mingw_mode", False )

# Shared library and compiled modules count, determines the need for the
# compiled module loader.
module_count = int( ARGUMENTS[ "module_count" ] )

# Frozen modules count, determines the need for the bytecode frozen
# modules loader.
frozen_modules = int( ARGUMENTS.get( "frozen_modules", 0 ) )

# Standalone mode
standalone_mode = getBoolOption( "standalone_mode", False )

# Show scons mode, output information about Scons operation
show_scons_mode = getBoolOption( "show_scons", False )

# Home of Python to be compiled against, used to find include files and libs
# to link against.
python_prefix = ARGUMENTS[ "python_prefix" ]

# Target arch, uses for compiler choice and quick linking of constants binary
# data.
target_arch = ARGUMENTS[ "target_arch" ]

# Icon for executable (windows-only)
icon_path = ARGUMENTS.get( "icon_path", None )

def createEnvironment( compiler_tools ):
    args = {}

    if os.name == "nt" and \
       not mingw_mode and \
       getExecutablePath( "cl", initial = True ) is not None:
        args[ "MSVC_USE_SCRIPT" ] = False

    return Environment(
        # We want the outside environment to be passed through.
        ENV         = os.environ,

        # Extra tools configuration for scons.
        tools       = compiler_tools,

        # The shared libraries should not be named "lib...", because CPython
        # requires the filename "module_name.so" to load it.
        SHLIBPREFIX = "",

        # Under windows, specify the target architecture is needed for Scons
        # to pick up MSVC.
        TARGET_ARCH = target_arch,

        # If we are on Windows, and MinGW is not enforced, lets see if we can
        # find "cl.exe", and if we do, disable automatic scan.
        **args
    )

def getExecutablePath( filename, initial ):
    # Variable substitution from environment is needed, because this can contain
    # "$CC" which should be looked up too.
    if filename.startswith( "$" ):
        filename = env[ filename[1:] ]

    # Append ".exe" suffix  on Windows if not already present.
    if os.name == "nt" and not filename.lower().endswith( ".exe" ):
        filename += ".exe"

    # Search in "PATH" environment for a file named like it.
    if os.name == "nt":
        separator = ";"
    else:
        separator = ":"

    # Either look at the initial "PATH" as given from the outside or look at the
    # current environment.
    if initial:
        search_path = os.environ[ "PATH" ]
    else:
        search_path = env._dict[ "ENV" ][ "PATH" ]

    # Now check in each path element, much like the shell will.
    path_elements = search_path.split( separator )

    for path_element in path_elements:
        full = os.path.join( path_element, filename )

        if os.path.exists( full ):
            return full
    else:
        return None

if mingw_mode:
    # Force usage of MinGW.
    compiler_tools = ["mingw"]
else:
    # Everything else should use default.
    compiler_tools = ["default"]

# Create Scons environment, the main control tool. Don't include "mingw" on
# Windows immediately, we will default to MSVC if available.
env = createEnvironment(
    compiler_tools = compiler_tools
)

# On Windows, in case MSVC was not found and not previously forced, retry with
# it and use that instead then as a fallback. Using both tools in one call
# seems to not work in terms of fallback when both exist.
if os.name == "nt" and \
   compiler_tools == ["default"] and \
   getExecutablePath(env[ "CXX" ], initial = False) is None:
    env = createEnvironment(
        compiler_tools = ["mingw"]
    )

if clang_mode:
    # If requested by the user, use the clang compiler, overriding what was
    # said in environment.
    env["CXX"] = "clang"
elif "CXX" in os.environ:
    # If the environment variable CXX is set, use that.
    env["CXX"] = os.environ["CXX"]

# To work around Windows not supporting command lines of greater than 10K by
# default:
def setupSpawn(env):
    def spawn( sh, escape, cmd, args, env ):
        # The "del" appears to not work, but is used with large amounts of
        # files to link. So, lets do this outselves, plus it avoids a process
        # spawn.
        if cmd == "del":
            os.unlink(args[1])
            return 0

        # For quoted arguments that end in a backslash, things don't work well
        # this is a workaround for it.
        def removeTrailingSlashQuote( arg ):
            if arg.endswith( r'\"' ):
                return arg[:-1] + '\\"'
            else:
                return arg

        newargs = ' '.join(
            removeTrailingSlashQuote( arg )
            for arg in
            args[1:]
        )
        cmdline = cmd + " " + newargs
        startupinfo = subprocess.STARTUPINFO()

        # CPython2.6 compatibility
        try:
            from subprocess import STARTF_USESHOWWINDOW
        except ImportError:
            from _subprocess import STARTF_USESHOWWINDOW

        startupinfo.dwFlags |= STARTF_USESHOWWINDOW

        proc = subprocess.Popen(
            cmdline,
            stdin       = subprocess.PIPE,
            stdout      = subprocess.PIPE,
            stderr      = subprocess.PIPE,
            startupinfo = startupinfo,
            shell       = False,
            env         = env
        )

        data, err = proc.communicate()
        rv = proc.wait()

        if cmd == "cl":
            data = data[ data.find( "\r\n" ) + 2 : ]

            source_basenames = [
                os.path.basename( source_file )
                for source_file in
                source_files
            ]

            def check( line ):
                return line in ( "",  "Generating Code..." ) or \
                       line in source_basenames

            data = "\r\n".join(
                line
                for line in
                data.split( "\r\n" )
                if not check( line )
            )

        elif cmd == "rc":
            data = data[ data.find( "reserved.\r" ) + 13 : ]

            data = "\n".join(
                line
                for line in
                data.split( "\n")
                if not "identifier truncated to"
            )
        elif cmd == "link" and module_mode:
            data = "\r\n".join(
                line
                for line in
                data.split( "\r\n" )
                if "   Creating library" not in line
            )

        if data.rstrip():
            if not show_scons_mode:
                print cmdline
            print data,

        return rv

    env["SPAWN"] = spawn

def getGccVersion():
    # Update CXXVERSION in env, after we changed it.
    import SCons

    pipe = SCons.Action._subproc(
        env, [ env[ "CXX" ], '--version' ],
        stdin  = 'devnull',
        stderr = 'devnull',
        stdout = subprocess.PIPE
    )

    line = pipe.stdout.readline()

    match = re.search( r'[0-9]+(\.[0-9]+){2}', line )

    if match:
        return match.group(0)
    else:
        return None

def getClangVersion():
    import SCons

    pipe = SCons.Action._subproc(
        env, [ env[ "CXX" ], '--version' ],
        stdin  = 'devnull',
        stderr = 'devnull',
        stdout = subprocess.PIPE
    )

    line = pipe.stdout.readline()

    match = re.search( r'LLVM ([0-9]+(\.[0-9]+){1})', line )

    if match:
        return match.group(1)

    match = re.search( r'([0-9]+(\.[0-9]+){1})', line )

    if match:
        return match.group(1)
    else:
        return None

# Some versions of Scons have unset or None, make it empty string.
if env.get( "CXX", None ) is None:
    env[ "CXX" ] = None

orig_cxx = env[ "CXX" ]
orig_cxx_version = env.get( "CXXVERSION", None )

# Remove "g++" as the compiler, in case it's not really existing or not high
# enough version.
if "g++" in ( env[ "CXX" ] or "" ):
    gpp_version = getGccVersion()

    if gpp_version is None or int( getGccVersion().replace( ".", "" ) ) < 440:
        env[ "CXX" ] = None

# Detect compiler to be used from supported ones, if there is no usable g++
# link.
if os.name != "nt" and env["CXX"] is None:
    for candidate in ( "g++-4.8", "g++-4.7", "g++-4.6", "g++-4.5", "g++-4.4",
                       "clang" ):
        if os.path.exists( os.path.join( "/usr/bin", candidate ) ):
            env[ "CXX" ] = candidate
            env[ "CC" ] = candidate.replace( "++", "cc" )

            if "clang" not in candidate:
                # Update CXXVERSION in env, after we changed it.
                env[ "CXXVERSION" ] = getGccVersion()

            break
    else:
        sys.exit( """\
The g++ compiler '%s' (version %s) doesn't have the sufficient \
version (>= 4.4).""" % ( orig_cxx, orig_cxx_version ) )

if show_scons_mode:
    print "Scons compiler: Using",
    print getExecutablePath( env[ "CXX" ], initial = False )

if env["CXX"] is None or \
   getExecutablePath( env[ "CXX" ], initial = False ) is None:
    if os.name == "nt":
        sys.exit( """\
Error, cannot locate suitable C++ compiler. You have the following options:

a) If a suitable Visual Studio version is installed, it not located,
   automatically unless you install pywin32 for the Python installation
   below "%s".

b) To make it find Visual Studio execute from Start Menu the 'Visual Studio
   Command Prompt' or "vcvarsall.bat". That will add Visual Studio to the
   PATH.

b) Install MinGW to 'C:\\MinGW' then it is automatically picked up.
""" % sys.exec_prefix )
    else:
        sys.exit( "Error, cannot locate suitable C++ compiler." )

gcc_mode = "g++" in env[ "CXX" ] or "clang" in env[ "CXX" ]
msvc_mode = win_target and not gcc_mode

if os.name == "nt" and msvc_mode:
    setupSpawn( env )

if os.name == "nt" and gcc_mode and target_arch == "x86_64":
    sys.exit( """\
Error, MinGW does not support 64 bit Python. Use MSVC or 32 bit Python instead.""" )


env[ "BUILD_DIR" ] = source_dir

# Store the file signatures database with the rest of the source files
sconsign_dir = os.path.abspath( os.path.join( source_dir, '.sconsign' ) )

if not os.path.exists( sconsign_dir ):
    os.makedirs( sconsign_dir )

env.SConsignFile( sconsign_dir )

# Support for clang.
if "clang" in env[ "CXX" ]:
    env.Append( CCFLAGS = [ "-w" ] )
    env.Append( CPPDEFINES = [ "_XOPEN_SOURCE" ] )
    env.Append( LINKFLAGS = [ "-lstdc++" ])

    # Don't export anything by default, this should create smaller executables.
    env.Append(
        CCFLAGS = [
            "-fvisibility=hidden",
            "-fvisibility-inlines-hidden"
        ]
    )

    if debug_mode and not clang_mode:
        env.Append( CCFLAGS = [ "-Wunused-but-set-variable" ] )

    clang_version = getClangVersion()
    clang_version = int( clang_version.replace( ".", "" ) + "0" )

# Support for g++.
if "g++" in env[ "CXX" ]:
    # Don't export anything by default, this should create smaller executables.
    if not win_target:
        env.Append( CCFLAGS = [
            "-fvisibility=hidden",
            ]
        )
        env.Append( CXXFLAGS = [
           "-fvisibility-inlines-hidden"
            ]
        )

    env[ "CXXVERSION" ] = getGccVersion()

    # Version dependent options.
    gpp_version = int( env[ "CXXVERSION" ].replace( ".", "" ) )

    # Enforce the minimum version, selecting a potentially existing g++-4.5
    # binary if it's not high enough. This is esp. useful under Debian which
    # allows all compiler to exist next to each other and where g++ might not be
    # good enough, but g++-4.5 would be.
    if gpp_version < 440:
        sys.exit( """\
The g++ compiler %s (version %s) doesn't have the sufficient \
version (>= 4.4).""" % ( env[ "CXX" ], env[ "CXXVERSION" ] ) )

    # Older g++ complains about aliasing with Py_True and Py_False, but we don't
    # care.
    if gpp_version < 450:
        env.Append( CCFLAGS = [ "-fno-strict-aliasing" ] )

    # For LTO mode, the version requirement is even higher, so try that too.
    if lto_mode and gpp_version < 460:
        sys.exit( """\
The g++ compiler %s (version %s) doesn't have the sufficient \
version for lto mode (>= 4.6).""" % ( env[ "CXX" ], env[ "CXXVERSION" ] ) )

    # For g++ 4.6 there are some new interesting functions.
    if gpp_version >= 460:
        env.Append( CCFLAGS = [ "-fpartial-inlining" ] )

        if debug_mode:
            env.Append( CCFLAGS = [ "-Wunused-but-set-variable" ] )

    # Use link time optimizations so that gcc can help with optimization across
    # files, but unfortunately at this time it seriously slows down the compiled
    # code. This may be because it needs -O3 option to be effective.

    if gpp_version >= 460 and lto_mode:
        env.Append( CCFLAGS = [ "-flto" ] )
        env.Append( LINKFLAGS = [ "-flto=%d" % GetOption( "num_jobs" ) ] )

        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=noreturn" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=pure" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=const" ] )
        # env.Append( CCFLAGS = [ "-Wnoexcept" ] )

        if debug_mode:
            env.Append( LINKFLAGS = [ "-O2" ] )

        if optimize_mode:
            env.Append( LINKFLAGS = [
                "-O3",
                "-fpartial-inlining",
                "-freorder-functions",
            ]
        )

    # Give a warning if LTO mode was specified, but won't be used.
    if lto_mode and gpp_version < 460:
        print >> sys.stderr, "Warning, LTO mode specified, but not available."

    # The var-tracking does not scale, disable it. Should we really need it, we
    # can enable it.
    env.Append( CCFLAGS = [ "-fno-var-tracking" ] )

if msvc_mode:
    env.Append( CCFLAGS = [ "/EHsc", "/J", "/Gd" ] )
    env.Append( LINKFLAGS = [ "/INCREMENTAL:NO" ] )

if debug_mode:

    if gcc_mode:
        # Allow g++/clang to point out all kinds of inconsistency to us by
        # raising an error.
        env.Append(
            CCFLAGS = [
                "-Wall",
                "-Werror"
            ]
        )

        # MinGW gives some non-sensical warnings it seems.
        if os.name == "nt":
            env.Append(
                CCFLAGS = [
                   "-Wno-error=format",
                   "-Wno-format"
                ]
            )
    elif msvc_mode:
        # Disable warnings that system headers already show.
        env.Append(
            CCFLAGS = [
                "/W4", "/wd4505", "/wd4127", "/wd4100", "/wd4702", "/wd4189",
                "/wd4211"
            ]
        )


    # As for sequence points, we are abusing it, so we have to allow it.
    if "g++" in env["CXX"]:
        env.Append(
            CCFLAGS = ["-Wno-sequence-point"]
        )

    # Benefit from clang checking memory accesses.
    if "clang" in env[ "CXX" ] and clang_version >= 330:
        env.Append(
            CCFLAGS = ["-fsanatize=address,bounds,return"]
        )

if full_compat_mode:
    env.Append(
        CPPDEFINES = ["_NUITKA_FULL_COMPAT"]
    )

if experimental_mode:
    env.Append(
        CPPDEFINES = ["_NUITKA_EXPERIMENTAL"]
    )

if standalone_mode:
    env.Append(
        CPPDEFINES = ["_NUITKA_STANDALONE"]
    )

    if win_target:
        # This is used for "PathRemoveFileSpec" used in standalone mode
        # Windows code.
        env.Append(
            LIBS = ["Shlwapi"]
        )
    elif "linux" in sys.platform:
        env.Append(
            LIBS = ["dl"]
        )

if win_target:
    # For MinGW and cross compilation, we need to tell the subsystem
    # to target as well as to automatically import everything used.
    if gcc_mode:
        env.Append(
            LINKFLAGS = ["-Wl,--enable-auto-import"]
        )

        if win_disable_console:
            env.Append(
                LINKFLAGS = ["-Wl,--subsystem,windows"]
            )

    if win_disable_console:
        env.Append(
            CPPDEFINES = ["_NUITKA_WINMAIN_ENTRY_POINT"]
        )


if python_debug:
    env.Append(
        CPPDEFINES = ["Py_DEBUG"]
    )

def detectHostMultiarch():
    import commands

    for line in commands.getoutput( "dpkg-architecture" ).split("\n"):
        if line.startswith("DEB_HOST_MULTIARCH="):
            return line.split( "=", 1 )[1]
    else:
        return None

if gcc_mode and "linux" in sys.platform:
    if python_version.startswith("3.3"):
        host_multiarch = detectHostMultiarch()

        if host_multiarch is not None:
            env.Append(
                CCFLAGS = [
                    "-I" + os.path.join(
                        "/usr/include/",
                        host_multiarch,
                        "python" + python_version
                    )
                ]
            )

if os.name == "nt":
    # On Windows, the installation layout is relatively fixed.
    python_header_path = os.path.join(python_prefix, "include")
else:
    # The python header path is a combination of python version and debug
    # indication, make sure the headers are found by adding it to the C++
    # include path.

    python_header_path = os.path.join(
        python_prefix,
        "include",
        "python" + python_version
    )

if not os.path.exists( os.path.join( python_header_path, "Python.h" ) ):
    # Not, for --python-debug other headers are used than for normal
    # compilation.
    sys.exit(
        """\
Error, no 'Python.h' %s headers can be found at '%s', dependency \
not satisfied!""" % (
            "debug" if python_debug else "development",
            python_header_path
        )
    )

env.Append( CPPPATH  = [ python_header_path ] )

if win_target:
    env.Append( LIBPATH = [ os.path.join( python_prefix, "libs" ) ] )
    env.Append( LIBS = [ "python" + python_version.replace( ".", "" ) ] )
else:
    # Debian and Ubuntu distinguish the system libraries like this.
    if python_debug and \
       python_prefix == "/usr" and \
       not python_version.startswith( "3" ) and \
       platform.dist()[0].lower() in ( "debian", "ubuntu" ):
        env.Append( LIBS = [ "python" + python_version + "_d" ] )
    else:
        env.Append( LIBS = [ "python" + python_version ] )

    if python_prefix != "/usr" and "linux" in sys.platform:
        env.Append(
            LIBS = ["dl", "pthread", "util", "m"]
        )

        if gcc_mode:
            env.Append(
                LINKFLAGS = ["-export-dynamic"]
            )


    # Add the python library path to the library path
    python_lib_path = os.path.join( python_prefix, "lib" )
    env.Append( LIBPATH = [ python_lib_path ] )

    # For NetBSD the rpath is required, on FreeBSD it's warned as unused.
    if "netbsd" in sys.platform:
        env.Append(
            LINKFLAGS = ["-rpath=" + python_lib_path]
        )

# The static include files reside in Nuitka installation, which may be where
# the "nuitka.build" package lives.
nuitka_include = os.path.join(
    nuitka_src,
    "include"
)

# We have include files in the build directory and the static include directory
# that is located inside Nuitka installation.
env.Append(
    CPPPATH = [
        source_dir,
        nuitka_include
    ]
)

if debug_mode or unstriped_mode:
    # Use debug format, so we get good tracebacks from it.
    if gcc_mode:
        env.Append(
            CCFLAGS = ["-g"]
        )
        env.Append(
            ASFLAGS = ["-g"]
        )

        if "g++" in env[ "CXX" ]:
            env.Append(
                CCFLAGS = ["-feliminate-unused-debug-types"]
            )
    elif msvc_mode:
        env.Append(
            CCFLAGS = ["/Zi"]
        )
        env.Append(
            LINKFLAGS = ["/DEBUG"]
        )

# When debugging, optimize less than when optimizing, when not remove
# assertions.
if debug_mode:
    if not optimize_mode:
        if gcc_mode or msvc_mode:
            env.Append(
                CCFLAGS = ["-O2"]
            )
else:
    env.Append(
        CPPDEFINES = ["__NUITKA_NO_ASSERT__"]
    )

if optimize_mode:
    if gcc_mode:
        env.Append(
            CCFLAGS = ["-O3"]
        )

        # Check inlining of calls, except in debug mode, where it will all be
        # wrong due to additional code.
        # if not debug_mode:
        #     env.Append( CCFLAGS = [ "-Winline" ] )
    elif msvc_mode:
        env.Append(
            CCFLAGS = ["/Ox"]
        )


# Set load libpython from binary directory default
if standalone_mode and gcc_mode:
    env.Append( LINKFLAGS = [ "-Wl,-R,'$$ORIGIN'" ] )

def getLinkerArch():
    if "linux" in sys.platform:
        if target_arch == "x86_64":
            return "elf64-x86-64"
        elif target_arch == "armv5tel":
            return "elf32-littlearm"
        else:
            # TODO: Detect from objdump mayhaps.
            return None
    else:
        # TODO: Missing for MacOS, FreeBSD, other Linux
        return None

constants_bin_filename = os.path.join(source_dir,"__constants.bin")

if win_target and not module_mode:
    # On Windows constants are accesses as a resource, see below
    constants_generated_filename = None
elif gcc_mode and getLinkerArch() is not None:
    env.Append(
        LINKFLAGS = [
            "-Wl,-b", "-Wl,binary",
            "-Wl,%s" % constants_bin_filename,
            "-Wl,-b", "-Wl,%s" % getLinkerArch(),
            "-Wl,-defsym",
            "-Wl,%sconstant_bin=_binary_%s___constants_bin_start" % (
                "_" if mingw_mode else "",
                "".join(re.sub("[^a-zA-Z0-9_]","_",c) for c in source_dir)
            )
        ]
    )

    constants_generated_filename = None
else:
    constants_generated_filename = os.path.join(
        source_dir,
        "__constants_data.c"
    )

    with open(constants_generated_filename, "w") as output:
        output.write("""const unsigned char constant_bin[] =\n{\n""")

        for count, stream_byte in enumerate(
                open(constants_bin_filename, "rb").read()
            ):
            if count % 16 == 0:
                if count > 0:
                    output.write("\n")

                output.write("   ")

            output.write(" 0x%02x," % ord(stream_byte))

        output.write("\n};\n");

env.Append(
    CPPDEFINES = ["_NUITKA_FROZEN=%d" % frozen_modules]
)

# Tell compiler to create a shared library or program.
if module_mode:
    if "g++" in env["CXX"]:
        env.Append(
            CCFLAGS = ["-shared"]
        )
    elif "clang" in env["CXX"]:
        pass
    elif msvc_mode:
        env.Append(
            CCFLAGS = ["/LD"]
        )
    else:
        assert False
else:
    if msvc_mode:
        env.Append(
            CCFLAGS = ["/MT"]
        )

if module_mode:
    env.Append(
        CPPDEFINES = ["_NUITKA_MODULE"]
    )
else:
    env.Append(
        CPPDEFINES = ["_NUITKA_EXE"]
    )

def discoverSourceFiles():
    result = []

    def getStatic( sub_path ):
       return os.path.join( static_src, sub_path.replace( "/", os.path.sep ) )

    result.append(getStatic("CompiledFunctionType.cpp"))
    result.append(getStatic("CompiledGeneratorType.cpp"))
    result.append(getStatic("CompiledMethodType.cpp"))
    result.append(getStatic("CompiledFrameType.cpp"))
    result.append(getStatic("CompiledCodeHelpers.cpp"))
    result.append(getStatic("InspectPatcher.cpp"))

    if win_target:
        result.append(getStatic("win32_ucontext_src/fibers_win32.cpp"))
    elif target_arch == "x86_64" and "linux" in sys.platform:
        result.append(getStatic("x64_ucontext_src/fibers_x64.cpp"))
        result.append(getStatic("x64_ucontext_src/swapfiber.S"))
    elif "arm" in target_arch:
        result.append(getStatic("arm_ucontext_src/fibers_arm.cpp"))
        result.append(getStatic("arm_ucontext_src/ucontext.cpp"))
        result.append(getStatic("arm_ucontext_src/getcontext.asm"))
    else:
        # Variant based on getcontext/setcontext/swapcontext/makecontext
        result.append(getStatic("gen_ucontext_src/fibers_gen.cpp"))

    for filename in os.listdir( source_dir ):
        if filename.endswith( ".cpp" ):
            result.append( os.path.join( source_dir, filename ) )

    # If more than one module is included, we need the unfreezer.
    if module_count > 1:
        result.append( getStatic( "MetaPathBasedLoader.cpp" ) )

    if constants_generated_filename is not None:
        result.append(constants_generated_filename)

    return result

source_targets = []

# Prepare the use of a custom specs file for windows targets. We change the used
# specs for linking to avoid the use of the wrong (for CPython) run time
# library.
if win_target:
    rc_content = []

    # Which files to depend on.
    rc_file_dependencies = []

    if not module_mode:

        rc_content.append(
            '3 RCDATA "%s"' % constants_bin_filename.replace( "\\", "/" )
        )

        rc_file_dependencies.append(constants_bin_filename)

        if python_version < "3.3" and msvc_mode:
            manifest_filename = os.path.join(
                source_dir,
                "resources.manifest"
            )

            assert 0 == subprocess.call(
                (
                    "mt",
                    "-inputresource:%s;#1" % os.path.join(
                        python_prefix,
                        "python.exe"
                    ),
                    "-out:%s" % manifest_filename
                ),
                stdout = subprocess.PIPE
            )

            rc_content.append(
                "1 RT_MANIFEST resources.manifest"
            )

            rc_file_dependencies.append(manifest_filename)

        if icon_path:
            rc_content.append(
                '2 ICON MOVEABLE PURE LOADONCALL DISCARDABLE "%s"' % (
                    icon_path.replace( "\\", "/" )
                )
            )

            rc_file_dependencies.append(icon_path)

    rc_filename = os.path.join( source_dir, "resources.rc" )

    rc_file = open(rc_filename, "w")

    rc_content.insert(
        0,
        '#include "winuser.h"'
    )
    rc_file.write("\n".join(rc_content))
    rc_file.close()

    res_target = env.RES(rc_filename)

    for rc_file_dependency in rc_file_dependencies:
        Depends(res_target, rc_file_dependency)

    source_targets.append(
        res_target
    )

source_files = discoverSourceFiles()

if module_mode:
    # For Python modules, the standard shared library extension is not what
    # gets used.
    if win_target:
        module_suffix = ".pyd"
    else:
        module_suffix = ".so"

    env["SHLIBSUFFIX"] = module_suffix

    target = env.SharedLibrary(
        result_basepath,
        source_files  + source_targets
    )
else:
    # Avoid dependency on MinGW libraries.
    if win_target and gcc_mode:
        env.Append( LINKFLAGS = [ "-static-libgcc",  "-static-libstdc++" ] )

    target = env.Program(
        result_basepath + ".exe",
        source_files + source_targets
    )

# Avoid IO for compilation as much as possible, this should make the
# compilation more memory hungry, but also faster.
if gcc_mode:
    env.Append( CCFLAGS = "-pipe" )

if "CCFLAGS" in os.environ:
    env.Append(CCFLAGS = os.environ[ "CCFLAGS" ].split())

if "LDFLAGS" in os.environ:
    env.Append(LINKFLAGS = os.environ[ "LDFLAGS" ].split())

# Remove the target file to avoid cases where it falsely doesn't get rebuild
# and then lingers from previous builds,
if os.path.exists(target[0].abspath):
    os.unlink(target[0].abspath)

if show_scons_mode:
    print "scons: Told to run compilation on %d CPUs." % GetOption( 'num_jobs' )

# Cached, when done, by the fastest possible algorithm and right inside the
# build directory. Makes no sense of course, if that is removed later on by
# Nuitka.
if cache_mode:
    CacheDir(os.path.join(source_dir, "cache"))
    Decider("MD5")

Default(target)
