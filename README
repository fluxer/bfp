## WARNING

This software is not complete and as such it does not represent the final
product. During the state of its development and stabilization major changes
may be done without explicit warning. It has known and unknown issues and
should be used with caution. You have been warned!

## WHAT

This collection of software includes libraries, tools, desktop applications,
coresponding documentation and configuration files.

They are written to suite my own needs but do not hesitate to join me and
improve the software if you like it, find it useful or something else. Note that
I do not follow code style much, but sanitising it can be done on demand, tough
it is done from time to time.

The purpose of the projects is to have a package of software that tries to
complete the GNU command line interface (CLI) and arsenal of tools offered with
minimum dependencies, written in easy to code programming language, integrated
into each other with only one thing in mind - KISS! If this does not suit you -
fine. Priorities of the projects - 1) speed, 2) stability, 3) security. If you
don't like it - fine!

In addition to the software a separate distribution had to be made to fulfill
the points mentioned above. It combines ideas and software in way that makes it
good base for what this project is aiming to achieve.

## WHY

Several key design features are taking place into this distribution as a whole:

- Source Package Manager
- BSD-style system initialization
- Busybox and Qt on top of custom Linux kernel
- True-rolling release model
- Stability and quality
- Really pure, no multilib cruft
- No /usr
- No Native Language Support (NLS) for CLI tools

The benefit of all this you may not get at first glance but there is explanation
for it all.

First of all, the core of the distribution - Source Package Manager or SPM for
short. It was designed with easy of use in mind so that building software and
having it "packaged" takes as less time as possible while preserving the soul
of the GNU/Linux ecosystem and that is software being easy to change to your
liking, something binary packages fail to fulfil by design because of
hard-versioned runtime dependencies and they not being ment to actually build
software (usually) for which you require extra tools. A good example of
situation where binary package managers are not good is when you need something
that has not been pre-package for the distribution you are using, then you have
to either package it yourself (the smart and harder aproach) or just install it
by hand and the distiribution package not knowing about it (the bad aproach,
what if you want to update the software?). Either way you will have to spend
quite some time in the begining and learn a lot of things, of course you will
with SPM too but once users get to know it they say it is "amazing!". You can
package/port any software you want, usually, in a few minutes on system which
uses SPM. Why? Because when it builds the software it automatically detects all
or most of the runtime dependencies that are required by the software being
build and installed reducing the effort you need to put into this by a lot. And
back to the point about of easy to change - imagine you need to patch or update
something imidiatly because of security or other reasons. You have to either
wait for the binary package maintainer to do this for you or do it yourself
which, in most cases means learning a new Programming Language (dpkg/make rules
or ebuilds anyone?). With SPM most system administrators are already familiar
with the Bourne Again SHell (Bash) which SPM uses for it's build recipes -
SRCBUILDs - similar to the Arch Linux PKGBUILDs format.

Init, PID 1, services, keyboard mash, hair on the ground. That's the havoc
you have to deal with when you go for something that starts a process in
the background thinking it is safe to do so relying on a dependency and
when a service(s) dependency chain has been broken because of power failure
or simple mistake you have to boot the damn thing by hand typing commands
in a TTY or get a rescue CD and start figuring it out in chroot by trying to
narrow down the problem in a runlevels and services dependcy chain hell?
Heck, no! A system boot sequence should not be done in parallel! Instead,
services can be, in some situations, ordered and background properly to boost
the process and improve the users experience - thus the use of initscripts in
this project. It has two runlevels - initialization and shutdown. In both most
of the actions taken are done in strict sequence without backgrounding by Bash
scripts which are very easy to modify (which you shouldn't have to do) or
plug into with hooks (the recommended method of doing modifications).

Busybox - the little miracle. It packs a lot of POSIX, and not so, compliant
tools that reduce the complications of porting and maintaining coreutils,
procps, less, diffutils, patch, tar, util-linux, dhcpcd, cron, sysvinit, grep,
findutils and a lot more separate projects. Ofcourse this does have its price
as some functionality is not present in the Busybox implementations but they
are usually not standard or highly unlikely used features. In any case, static
Busybox is a life saver and most distributions are using it in their initramfs
implementations anyway.

Rolling release model has been chosen to reduce to complexity and improve the
end-users experience by avoiding a lot of major upgrades at the same time which
is more suitable for a source based distribution. But there are things that the
other rolling release distribution are missing and that is avoiding constant
shape-shifting software. This project uses the old-stable, bugfix or LTS (Long
Term Support) releases provided by upstream and using it until the next one is
out. An example is Git, currently there are 2.0.4 and 2.0.1 versions available,
this project ships 2.0.4 to make sure that no show-stopper and security bugs
are present and give upstream time to fix them, if any, in the new major
release. This includes the kernel which is updated every few months or so.
Also, the software ports do not provide bell and whistles by default. systemd,
PAM, ConsoleKit (which is pretty much dead), and other not very well
implemented tools that can cause troubles with halting, hibernating or even
login into to your setup are avoided where possible.

Multilib is a architecture mixup, disaster and something every distribution
handles on its own, in different way. With binary packages there are always
headaches, while this may not be such a problem for this project it is not
considered a good thing to support as the upstream software should have long
ago started to realize that i386 is not the only architecture out there and,
for their own good, support it. It can cause a lot of end-users to give up on
a producet if it does not deliver what it is supposed to - a good experience.

There are a few more extreme things in the hearth of the project - the drop of
the /usr directory support and Native Languages Support (NLS) for the Command
Line Interface (CLI). Having separate /usr causes major confusion and
non-portability issue of software. While some upstream projects are going the
other way placing everything in /usr leaving only /var and /etc on the root
we think it should be other way around because in most situations where
separate /usr is a good thing a separate /var also is, maybe /etc too. As such
different partition and more suitable filesystem type is chosen. And most
imprtantly you do not have to scale trough /bin, /sbin, /lib, /usr/lib to find
the binaries or libraries you are looking for which goes the same way for your
hard-drive. NLS support for the CLI is another feature that has been drift off
because in most cases it does does not bring any good to the Graphical User
Interface and is/should be rarely access. In addition it can cause issues with
resolving problems with upstream because logs and outputs for an example are in
language that is not know by developers, contributors and the like. Altought
people from all around the work are involved in open-source projects they are
not always avaialble and it takes much more time and effort to get things
sorted when it comes to key components such as software failing to build and
having to grasp trrough hundreds of lines of output in different language is
"awesome!". This may not suite administrators and users but, hopefully, it will
increase the rate of which upstream software resolves their issues quicker
making the GNU/Linux userland far more pleasant to deal with without the bugs
interfiering.

The following text does not cover all pros and cons of the picture as a whole,
for more details on some of the components there is a separate help page that
you should read.

## WHO

Here is a incomplete list of people who are or were involved in the project in
one way or another, thank you for your support:

### Current contributors

- Ivailo Monev (a.k.a. SmiL3y) <xakepa10@gmail.com>

### Past contributors

- pablokal, handy, ArchVortex and other [ArchBang](http://www.archbang.org/)
forums users
- Jubei Mitsuyoshi
- Marcus (a.k.a. artoo/udeved) <udeved@openrc4arch.site40.net>
- Adil Ãœnal (a.k.a. turkbits) <turkbits@turkbits.net>

If you think you have the right to be mentioned here but you are not feel free
contact us!
